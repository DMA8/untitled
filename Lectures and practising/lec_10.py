A = [1,3,3,6,7,9]
def left_bound(A,key):

    left_pos = -1
    right_pos = len(A)
    while right_pos - left_pos >1:
        mid = (left_pos + right_pos) //2
        if A[mid] < key:
            left_pos = mid
        else:
            right_pos = mid
    return left_pos

def right_bound(A,key):
    left_pos = -1
    right_pos = len(A)
    while right_pos - left_pos >1:
        mid = (left_pos + right_pos) //2
        if A[mid] <= key:
            left_pos = mid
        else:
            right_pos = mid
    return right_pos

#Позелно тем, что мы находим левую границу, куда вставлять
# нужный элемент в упорядоченном виде

#ДИНАМИЧЕСКОЕ ПРОГРАММИРОВАНИЕ
#пишем функцию вычисление чисел фибонначи
def fib(n):
    '''
    проблема в том, что очень долго считает. Число операций = числу фибоначи
    по памяти здесь тоже не все очевидно. Занимает много памяти, но мы просто этого не видим
    :param n:
    :return:
    '''
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)

#Динамический подход - создать таблицу со значениями фибоначи
# не вычислять их каждый раз. Заполнить массив и просто из него брать нужные значения

def din_fib(N):
    fib_database = [0]*2
    fib_database[0] = 0
    fib_database[1] = 1
    for i in range(2,N+1):

        fib_database.append((fib_database[i-1] + fib_database[i-2]))
    return print(fib_database[N])
din_fib(7)


##Задача про кузнечика
# он может прыгать на 1 или 2 клетки вперед. Сколько различных траекторий
# может быть? Сколько вариантов у кузнечика допрыгать до нужной точки?


# решаем рекурсивно: В точку назначения N можно попасть только из N-1 и N-2 (последний прыжок)
# K(N) = K(N-2) + K(N-1) K - количество траекторий N - координата последней точки

# Если решать рекурсивно - нарываемся на чила фибоначи -> очень долго
#Начинаем слева направо - динамическим способом
# - добавляем клети, в которые нельзя попасть - клетка 0

def traj_num(N):
    """
    создаем массив, соответствующий табличке количеств К
    (позиция и кол-во траекторий достигнуть ее)

    :param N:
    :return:
    """
    K = [0,1] + [0] * N
    for i in range(2, N+1):
        K[i] = K[i-2] + K[i-1]
    return K[N] # получили задачу по числам фибоначи

#усложнаяем задачу - сделаем запрещенные клетки
# нельзя наступать на 4 и 7-ю клетки

# как передать запрещенные клетки в функцию?
# - передает массив лог значений с разрешениями по координате

# двигаемся слева направо. если клетка запрещенная, то записываем "сюда ноль способов попасть"
# а когда прыгаем из запрещенной - то этот 0 просто не попадет в кол-во траекторий к след клетке

permitions = [False, True,True,True,False,True,False,True,False]
def coun_traj(N, allowed:list):
    '''создаем массив  разрешений траекторий'''
    K = [0,1,int(allowed[2])] + [0]*(N-3)

    for i in range(3,N+1):
        if allowed[i]:
            K[i] = K[i-1] + K[i-2] + K[i-3]
    return K[-1]
#print(coun_traj(8,permitions))

#Расчет минимальной стоимости достижения клетки N
# за посещение клеток, теперь надо платить
#price[i] - цена за посещение i клетки
# C[i] - минимальная стоимость достижения клетки N

def count_min_cost(N, price:list):
    '''price - список цен'''
    #мин стоимость посещ. i клетки - плата за i клетку и минимум из мин стоимости пред.клеток
    # начало вычисляем руками -
    # C1 = price1      C2 = price1 + price2
    C = [float('-inf'), price[1], price[2]+price[1],] + [0]*(N-2)
    for i in range(3,N+1):
        C[i] = price[i] + min(C[i-2],C[i-1])
    return C[N]

#Создание 2мерн массивов
X = [[0]*M for i in range(N)]
