# динамическое программирование с двумерными задачами

# Задача о ходах шахматного короля
"""
Сколькими способами шахматный король достигнет Нточки, если он может ходить вниз и вправо

Knm - кол-во способов достичь клетки (n,m)

Kij = K(i-1)j + Ki(j-1)
"""
#ЕСТЬ ПАРАЛЕЛЛЬНОЕ ПРОГРАММИРОВАНИЕ ЕЩЕ. Некоторые операции проходят параллельно на
# на разных ядрах/потоках. Используется в супер-задачах при больших объемах.
# если задача очень сложная, то задействуют многоядерность
def traj_counter(N:int, M:int):
    '''
    The King goes only to the right and down
    N and M - the point on the field. It's a target and we gotta count
    numbers of possible trajectories up to the target from the beginning
    :param N:
    :param M:
    :return:
    '''
    # Let's create a field:
    K = [[0]*(M+1) for i in range(N+1)]
    K[0][0] = None
    '''
    это можно не писать, так как все уже залито нулями
    for i in range(1,len(K[0])):
        K[0][i] = 0
    for i in range(1,len(K)):
        K[i][0] = 0'''
    K[1][1] = 1
    print(*K, sep='\n')

    # Let's fill each cell like K[i][j] = K[i-1][j] + K[i][j-1]
    for i in range(1,len(K)):
        for j in range(1,len(K[i])):
            if i == j == 1:
                continue
            K[i][j] = K[i-1][j] + K[i][j-1]
    print('step2')
    print(*K, sep='\n')
    return K[N][M]
#print(traj_counter(3, 5))


# НАИБОЛЬШАЯ ОБЩАЯ ПОСЛЕДОВАТЕЛЬНОСТЬ
"""
Постановка задачи:
1. А, В - массивы чисел. (одномерные). len(A) == N, len(B) == M
Интересует - какая максимально возможная подпоследовательность у них общая
подпоследовательность - список С, содержащий только элементы А в исходном порядке, но 
возможно не все.

(можно найти целевую функцию, которую легко подсчитать,
например вычислить длину наиб общ подпослед-ти)

заранее вводим Fij. Давайте рассматривать подпоследовательности не для полных А и В,
а возьмем только части от А и В
Fij - длина наиб возможной подпоследовательности, но не А и В, а их частей
Часть А длины i - A[0:i]. Часть А, первые i элементов
Часть В длины j - B[0:j]. Часть В, первые j элементов

Составляем рекурентное соотношение так, чтобы эта задача свелась 
к поиску НОП для меньших кусков

Когда 2 послед эл-та равны друг другу. То 

"""
def lcs(A,B):
    F = [[0]*(len(B)+1) for i in range(len(A)+1)] #крайний случай
    T = [] # сама подпоследовательность
    for i in range(1,len(A)+1):
        for j in range(1,len(B)+1):
            if A[i-1] == B[j-1]:
                F[i][j] = 1 + F[i-1][j-1]
                T.append(A[i-1])
            else:
                F[i][j] = max(F[i-1][j], F[i][j-1])
    print(T)
    return F[-1][-1]
A = [1,2,4,8,1,1,8]
B = [1,7,4,9,5,5,5]
print(lcs(A,B))










